<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SVG Mind Tree — Sequence & Branch Editor</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --bg:#0f1724; --panel:#0b1220; --muted:#9aa4b2; --accent:#1976d2; --danger:#d32f2f; --glass: rgba(255,255,255,0.03); }
    html,body { height:100%; margin:0; font-family:Inter, Arial, sans-serif; background:var(--bg); color:#e6eef6; overflow:hidden; }
    #app { height:100%; display:flex; }
    #left { width:360px; padding:12px; box-sizing:border-box; background:linear-gradient(180deg,var(--panel), #07101a); box-shadow: 12px 0 30px rgba(0,0,0,0.6); overflow:auto; }
    #left h2 { margin:6px 0 10px 0; font-size:18px; }
    button { border:none; border-radius:6px; padding:8px 10px; cursor:pointer; font-weight:600; }
    .btn { background:var(--accent); color:white; display:block; width:100%; margin-bottom:8px; }
    .btn.ghost { background:transparent; border:1px solid rgba(255,255,255,0.06); color:#cfe3ff; }
    .btn.danger { background:var(--danger); }
    .info { font-size:13px; color:var(--muted); margin-bottom:8px; }
    .small { font-size:13px; color:#c9d6e8; }
    .row { display:flex; gap:8px; margin-bottom:8px; }
    input, textarea, select { width:100%; padding:8px; border-radius:6px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit; box-sizing:border-box; }
    label { display:block; margin-bottom:6px; font-size:13px; color:var(--muted); }

    #svgWrap { flex:1; position:relative; }
    #svgCanvas { width:100%; height:100%; background: linear-gradient(180deg,#071219,#05101a); display:block; cursor:grab; }

    /* UI panels inside canvas */
    #topBanner { position:absolute; left:50%; transform:translateX(-50%); top:10px; background:rgba(0,0,0,0.6); padding:6px 10px; border-radius:8px; z-index:10; display:none; font-weight:700; }
    #longtext { position:absolute; right:12px; bottom:12px; width:360px; max-height:40vh; overflow:auto; background:rgba(10,10,12,0.92); padding:12px; border-radius:8px; box-shadow:0 8px 30px rgba(0,0,0,0.6); display:none; z-index:20; }
    #cameraControls { position:absolute; right:12px; top:12px; z-index:20; display:flex; gap:8px; }

    /* pen panel */
    #penPanel {
      position:absolute; right:12px; top:60px; width:360px; max-height:50vh; overflow:auto;
      background:rgba(6,10,14,0.95); padding:10px; border-radius:8px; box-shadow:0 8px 30px rgba(0,0,0,0.6); display:none; z-index:40;
      font-size:13px; color:#dff0ff;
    }
    #penPanel .log { font-family:monospace; color:#cfe3ff; margin-bottom:6px; white-space:pre-wrap; font-size:13px; border-bottom:1px dashed rgba(255,255,255,0.03); padding-bottom:6px; }
    #penPanel .meta { color:var(--muted); font-size:12px; margin-bottom:8px; }

    /* node label */
    .node-label { font-size:12px; fill:#eaf6ff; pointer-events:none; text-anchor:middle; dominant-baseline:middle; font-weight:700; text-shadow: 0 1px 0 rgba(0,0,0,0.6); }

    /* modal */
    .modal { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,0.45); z-index:200; }
    .modal .box { width:520px; max-width:96%; background:#071827; padding:14px; border-radius:8px; color:#e6eef6; box-shadow:0 8px 30px rgba(0,0,0,0.6); }
    .actions { display:flex; gap:8px; justify-content:flex-end; margin-top:10px; }

    footer { position:absolute; left:12px; bottom:12px; color:var(--muted); font-size:13px; z-index:50; }

    .linkish { background:transparent; color:var(--accent); border:1px solid rgba(25,118,210,0.18); }
    .muted-block { color:var(--muted); font-size:13px; margin-top:6px; }
    #allNodesList { max-height:160px; overflow:auto; font-size:13px; margin-top:6px; }
  </style>
</head>
<body>
  <div id="app">
    <div id="left">
      <h2>SVG Mind Tree</h2>
      <button id="createBtn" class="btn">+ Create Node</button>
      <button id="genBtn" class="btn ghost">Generate Random Graph</button>
      <button id="adminBtn" class="btn ghost">Admin Panel</button>
      <button id="clearBtn" class="btn danger">Clear Scene</button>
	  
	  <!-- add this inside the existing #cameraControls (near Fit / Pen / Analyze buttons) -->
	  <button id="textGraphBtn" class="btn ghost">Build from Text</button>
	  
	  


      <div class="info">Select a node to see details. Hold <strong>SHIFT</strong> then click another node to create a connection (selected → clicked).</div>

      <h3 id="nodeTitle">No node selected</h3>
      <div id="nodeInfo" class="small">
        <div><strong>ID:</strong> <span id="nodeId">—</span></div>
        <div><strong>Pos:</strong> <span id="nodePos">—</span></div>
        <div><strong>Created:</strong> <span id="nodeCreated">—</span></div>
        <div><strong>Desc:</strong> <div id="nodeDesc">—</div></div>
        <div style="margin-top:8px;">
          <button id="openUpdateBtn" class="btn ghost" style="display:none;">Edit Node</button>
          <button id="createBranchBtn" class="btn linkish" style="display:none;">Create Branch</button>
        </div>
        <div style="margin-top:8px;">
          <label>Quick select by ID</label>
          <div class="row"><input id="quickSelectId" placeholder="#123" /><button id="quickSelectBtn" class="btn ghost">Go</button></div>
        </div>

        <div style="margin-top:10px;">
          <label>All nodes</label>
          <div id="allNodesList"></div>
        </div>
      </div>
    </div>

    <div id="svgWrap">
      <div id="topBanner">Hold SHIFT + click another node to connect (selected → clicked)</div>

      <div id="cameraControls">
        <button id="fitBtn" class="btn ghost">Fit</button>
        <button id="toggleLong" class="btn ghost">Toggle Long Text</button>
        <button id="playBtn" class="btn ghost">Play ▶</button>
        <button id="penBtn" class="btn ghost">Pen ✏️</button>
        <button id="analyzeBtn" class="btn ghost">Analyze Path</button>
      </div>

      <svg id="svgCanvas" viewBox="-500 -350 1000 700" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <marker id="arrow" markerWidth="7" markerHeight="7" refX="7" refY="3.5" orient="auto">
            <path d="M0,0 L7,3.5 L0,7 z" fill="#cbe4ff"/>
          </marker>
          <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.6"/>
          </filter>
        </defs>
        <g id="connections"></g>
        <g id="nodes"></g>
      </svg>

      <div id="penPanel">
        <div class="meta"><strong>PEN MODE / LOGS</strong></div>
        <div id="penMeta"></div>
        <div id="penLogs"></div>
        <div style="margin-top:8px; display:flex; gap:8px;">
          <button id="clearPenLogs" class="btn ghost" style="flex:1">Clear logs</button>
          <button id="closePen" class="btn" style="flex:1">Close</button>
        </div>
      </div>

      <div id="longtext"></div>

      <!-- Create Node Modal (reused for new node edit) -->
      <div id="modal-update" class="modal"><div class="box">
        <h3>Update Node <span id="updNodeLabel" class="small"></span></h3>
        <label>Name <input id="updName" /></label>
        <label>Description (short) <textarea id="updDesc" rows="2"></textarea></label>
        <label>Text (long) <textarea id="updText" rows="4"></textarea></label>
        <label>Coordinates (x,y) <input id="updCoords" placeholder="x,y" /></label>
        <div class="actions">
          <button id="cancelUpdate" class="btn ghost">Cancel</button>
          <button id="submitUpdate" class="btn">Save</button>
        </div>
      </div></div>

      <!-- Generate Modal -->
      <div id="modal-gen" class="modal"><div class="box">
        <h3>Generate Random Graph</h3>
        <label>How many nodes? <input id="genCount" type="number" min="1" max="200" value="6" /></label>
        <div class="actions">
          <button id="cancelGen" class="btn ghost">Cancel</button>
          <button id="submitGen" class="btn">Generate</button>
        </div>
      </div></div>
	  
	  <!-- Paste near your other modal elements (modal-create/modal-gen/etc.) -->
<div id="modal-textgraph" class="modal">
  <div class="box">
    <h3>Build Graph From Text</h3>
    <label>Paste your text (each word becomes a node in sequence):</label>
    <textarea id="textGraphArea" rows="8" placeholder="Paste text here..."></textarea>
    <div style="margin-top:8px; display:flex; gap:8px; justify-content:flex-end;">
      <button id="textGraphCancel" class="btn ghost">Cancel</button>
      <button id="textGraphGenerate" class="btn">Generate Graph</button>
    </div>
    <div style="margin-top:10px; color:var(--muted); font-size:13px;">Note: this will create nodes in order. First word becomes a standalone node, subsequent words connect as a sequence to the previous word.</div>
  </div>
</div>


    </div>
  </div>

  <footer>SVG Mind Tree — pan: drag background, zoom: wheel, connect: SHIFT + click</footer>

<script>
/* ---------- Core client logic (SVG-based editor) with Pen, immediate-edit modal on create, and Analyze tool ---------- */

const svg = document.getElementById('svgCanvas');
const nodesG = document.getElementById('nodes');
const connsG = document.getElementById('connections');
const topBanner = document.getElementById('topBanner');
const longtext = document.getElementById('longtext');

let viewBox = { x: -500, y: -350, w: 1000, h: 700 };
function setViewBox() { svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`); }
setViewBox();

// small helper
function escapeHtml(s) {
  if (s === null || s === undefined) return '';
  return String(s).replace(/[&<>"']/g, ch => ({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[ch]);
}

// pan/zoom state
let isPanning = false, startPan = null;
svg.addEventListener('mousedown', (e) => {
  if (e.target === svg || e.target === svg.parentNode) {
    isPanning = true; startPan = {x:e.clientX, y:e.clientY, vb:Object.assign({}, viewBox)};
    svg.style.cursor = 'grabbing';
  }
});
window.addEventListener('mousemove', (e) => {
  if (!isPanning) return;
  const dx = (e.clientX - startPan.x) * (viewBox.w / svg.clientWidth);
  const dy = (e.clientY - startPan.y) * (viewBox.h / svg.clientHeight);
  viewBox.x = startPan.vb.x - dx;
  viewBox.y = startPan.vb.y - dy;
  setViewBox();
});
window.addEventListener('mouseup', () => { isPanning = false; svg.style.cursor='grab'; });

// wheel zoom (center under cursor)
svg.addEventListener('wheel', (e) => {
  e.preventDefault();
  const rect = svg.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const cx = viewBox.x + (mx / rect.width) * viewBox.w;
  const cy = viewBox.y + (my / rect.height) * viewBox.h;
  const zoomFactor = e.deltaY > 0 ? 1.12 : 0.88;
  viewBox.w *= zoomFactor; viewBox.h *= zoomFactor;
  viewBox.x = cx - (mx / rect.width) * viewBox.w;
  viewBox.y = cy - (my / rect.height) * viewBox.h;
  setViewBox();
}, { passive:false });

// data caches
let nodesMap = new Map(); // id -> node
let connsMap = new Map(); // id -> connection
let selectedNodeId = null;
let ctrlPressed = false;
let shiftPressed = false;

// PLAY state
let isPlaying = false;
let playIntervalMs = 1000;
let playingNodeId = null;
let playingPathEdgeIds = new Set();
let playTimeout = null;
const playBtn = document.getElementById('playBtn');

// keyboard
window.addEventListener('keydown', (e) => {
  if (e.key === 'Shift') { shiftPressed = true; if (selectedNodeId) topBanner.style.display='block'; }
  if (e.key === 'Control') ctrlPressed = true;
  if (e.key === 'Escape') document.querySelectorAll('.modal').forEach(m => m.style.display='none');
});
window.addEventListener('keyup', (e) => {
  if (e.key === 'Shift') { shiftPressed = false; topBanner.style.display='none'; }
  if (e.key === 'Control') ctrlPressed = false;
});

// ---------- PEN tool state ----------
let penModeActive = false;
let penDrawing = false;
let penStart = null;        // { x, y } in svg coords
let penStartNodeId = null;  // id of node under start (if any)
let penPoly = null;         // temporary polyline element
const penBtn = document.getElementById('penBtn');
const penPanel = document.getElementById('penPanel');
const penLogsEl = document.getElementById('penLogs');
const penMetaEl = document.getElementById('penMeta');
const clearPenLogsBtn = document.getElementById('clearPenLogs');
const closePenBtn = document.getElementById('closePen');
const analyzeBtn = document.getElementById('analyzeBtn');

function clientToSvg(clientX, clientY) {
  const rect = svg.getBoundingClientRect();
  const mx = clientX - rect.left;
  const my = clientY - rect.top;
  const x = viewBox.x + (mx / rect.width) * viewBox.w;
  const y = viewBox.y + (my / rect.height) * viewBox.h;
  return { x, y };
}

function addPenLog(msg) {
  const t = new Date().toLocaleTimeString();
  const div = document.createElement('div');
  div.className = 'log';
  div.textContent = `[${t}] ${msg}`;
  penLogsEl.prepend(div);
}
function setPenMeta(text) { penMetaEl.textContent = text; }

penBtn.addEventListener('click', () => {
  penModeActive = !penModeActive;
  if (penModeActive) enterPenMode(); else exitPenMode();
});
clearPenLogsBtn.addEventListener('click', () => { penLogsEl.innerHTML = ''; });
closePenBtn.addEventListener('click', () => { penModeActive = false; exitPenMode(); });

function enterPenMode() {
  penPanel.style.display = 'block';
  svg.style.cursor = 'crosshair';
  penBtn.textContent = 'Pen ✏️ (on)';
  addPenLog('PEN MODE activated');
  setPenMeta('Move cursor to see position and hovered node. Press left mouse to start drawing.');
}
function exitPenMode() {
  penPanel.style.display = 'none';
  svg.style.cursor = 'grab';
  penBtn.textContent = 'Pen ✏️';
  addPenLog('PEN MODE deactivated');
  penDrawing = false;
  removeTempPenElements();
}

function createTempPolyline() {
  removeTempPenElements();
  penPoly = document.createElementNS('http://www.w3.org/2000/svg','polyline');
  penPoly.setAttribute('fill','none');
  penPoly.setAttribute('stroke','#ffd166');
  penPoly.setAttribute('stroke-width','2');
  penPoly.setAttribute('stroke-linecap','round');
  penPoly.setAttribute('stroke-linejoin','round');
  svg.appendChild(penPoly);
}
function removeTempPenElements() {
  if (penPoly && penPoly.parentNode) penPoly.parentNode.removeChild(penPoly);
  penPoly = null;
}

// detect node under a position (same radius as render)
function detectNodeAt(svgX, svgY) {
  const radius = 18;
  let found = null;
  for (const n of nodesMap.values()) {
    if (n.x == null || n.y == null) continue;
    const dx = Number(n.x) - svgX;
    const dy = Number(n.y) - svgY;
    const d = Math.sqrt(dx*dx + dy*dy);
    if (d <= radius) {
      if (!found || d < found.dist) found = { id: n.id, dist: d, node: n };
    }
  }
  return found;
}

// live meta update while pen mode active
window.addEventListener('pointermove', (ev) => {
  if (!penModeActive) return;
  const pos = clientToSvg(ev.clientX, ev.clientY);
  const hit = detectNodeAt(pos.x, pos.y);
  setPenMeta(`cursor: ${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}   hovered node: ${hit ? '#' + hit.id : '(none)'}`);
  if (penDrawing) {
    if (!penPoly) createTempPolyline();
    const pts = (penPoly.getAttribute('points') || '').trim();
    const add = `${pos.x},${pos.y}`;
    penPoly.setAttribute('points', pts ? `${pts} ${add}` : add);
    addPenLog(`drawing... ${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}   over: ${hit ? '#' + hit.id : '(none)'}`);
  }
});

// start drawing on svg background (left mouse)
svg.addEventListener('pointerdown', (ev) => {
  if (!penModeActive) return;
  if (ev.button !== 0) return;
  ev.preventDefault(); ev.stopPropagation();
  const pos = clientToSvg(ev.clientX, ev.clientY);
  const hit = detectNodeAt(pos.x, pos.y);
  penStart = pos;
  penStartNodeId = hit ? hit.id : null;
  penDrawing = true;
  createTempPolyline();
  penPoly.setAttribute('points', `${penStart.x},${penStart.y}`);
  addPenLog(`pen down at ${penStart.x.toFixed(1)}, ${penStart.y.toFixed(1)}   start node: ${penStartNodeId ? '#' + penStartNodeId : '(none)'}`);
  svg.setPointerCapture && svg.setPointerCapture(ev.pointerId);
});

// pointerup finalizes: create node POST, then open edit modal
window.addEventListener('pointerup', async (ev) => {
  if (!penModeActive || !penDrawing) return;
  if (ev.button !== 0) return;
  const pos = clientToSvg(ev.clientX, ev.clientY);
  const hitEnd = detectNodeAt(pos.x, pos.y);
  addPenLog(`pen up at ${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}   end node: ${hitEnd ? '#' + hitEnd.id : '(none)'}`);
  penDrawing = false;

  const payload = { name: `Drawn Node`, x: pos.x, y: pos.y, sequence: true };
  if (penStartNodeId != null) payload.connect_to = Number(penStartNodeId);
  addPenLog(`creating node payload: ${JSON.stringify(payload)}`);

  try {
    const r = await fetch('/api/nodes', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(payload)
    });
    if (!r.ok) {
      const txt = await r.text();
      addPenLog(`server error creating node: ${txt}`);
    } else {
      const created = await r.json();
      addPenLog(`created node id #${created.id} at ${created.x},${created.y}`);
      // refresh scene and select created
      await loadData();
      if (created && created.id) {
        selectNode(created.id);
        // open update modal so user can edit name/desc/text immediately
        openUpdateModal(created.id, { focusFirst: true });
      }
    }
  } catch (err) {
    addPenLog('network error creating node: ' + err);
  } finally {
    removeTempPenElements();
    penStart = null;
    penStartNodeId = null;
    svg.releasePointerCapture && svg.releasePointerCapture();
  }
});

// ---------- Helper graph traversal utilities ----------

function getOutgoing(nodeId) {
  return Array.from(connsMap.values()).filter(c => Number(c.source) === Number(nodeId));
}
function getIncoming(nodeId) {
  return Array.from(connsMap.values()).filter(c => Number(c.target) === Number(nodeId));
}

function findRoot(startNodeId) {
  let current = startNodeId;
  const seen = new Set();
  while (true) {
    if (seen.has(current)) break;
    seen.add(current);
    const inc = getIncoming(current);
    if (!inc || inc.length === 0) break;
    current = inc[0].source;
  }
  return current;
}

function chooseNextConnectionForNode(node) {
  const outs = getOutgoing(node.id);
  if (!outs || outs.length === 0) return null;
  if (outs.length === 1) return outs[0];

  const desc = (node.description || '');
  const matches = Array.from(desc.matchAll(/\#\s*([0-9]+)/g)).map(m => Number(m[1]));

  if (matches.length > 0) {
    for (const wantedId of matches) {
      const found = outs.find(c => Number(c.target) === Number(wantedId));
      if (found) return found;
    }
  }

  outs.sort((a, b) => a.id - b.id);
  return outs[0];
}

function traceSequenceFromRoot(rootId) {
  const path = [];
  const visitedNodes = new Set();
  let currentId = rootId;
  while (currentId != null && !visitedNodes.has(currentId)) {
    visitedNodes.add(currentId);
    const node = nodesMap.get(Number(currentId));
    if (!node) break;
    path.push(node);
    const nextConn = chooseNextConnectionForNode(node);
    if (!nextConn) break;
    currentId = Number(nextConn.target);
  }
  return path;
}

function edgesForPathNodes(pathNodes) {
  const edges = [];
  for (let i = 0; i < pathNodes.length - 1; i++) {
    const a = pathNodes[i];
    const b = pathNodes[i+1];
    const conn = Array.from(connsMap.values()).find(c => Number(c.source) === Number(a.id) && Number(c.target) === Number(b.id));
    if (conn) edges.push(conn.id);
  }
  return edges;
}

// ---------- rendering ----------

function renderNodes() {
  nodesG.innerHTML = '';
  for (const [id, n] of nodesMap.entries()) {
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('data-id', id);
    g.setAttribute('transform', `translate(${n.x}, ${n.y})`);
    g.style.cursor = 'pointer';

    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circle.setAttribute('r', 18);

    if (playingNodeId && Number(playingNodeId) === Number(id)) {
      circle.setAttribute('fill', '#f1c40f');
    } else if (Number(id) === Number(selectedNodeId)) {
      circle.setAttribute('fill', '#ffb86b');
    } else {
      circle.setAttribute('fill', '#1976d2');
    }

    circle.setAttribute('stroke', 'rgba(255,255,255,0.06)');
    circle.setAttribute('stroke-width', 1.5);
    circle.setAttribute('filter', 'url(#shadow)');
    g.appendChild(circle);

    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
    label.setAttribute('class', 'node-label');
    label.textContent = `#${id} ${n.name||''}`;
    label.setAttribute('y', 0);
    g.appendChild(label);

    g.addEventListener('mousedown', (ev) => { ev.stopPropagation(); });
    g.addEventListener('click', (ev) => onNodeClick(ev, id));
    g.addEventListener('dblclick', (ev) => { ev.stopPropagation(); openUpdateModal(id); });

    let dragging = false, dragStart = null, orig = null;
    g.addEventListener('pointerdown', (ev) => {
      // If pen mode is active, start pen from this node
      if (penModeActive) {
        ev.preventDefault(); ev.stopPropagation();
        const pos = clientToSvg(ev.clientX, ev.clientY);
        penStart = pos;
        penStartNodeId = id;
        penDrawing = true;
        createTempPolyline();
        penPoly.setAttribute('points', `${penStart.x},${penStart.y}`);
        addPenLog(`pen down (on node) at ${penStart.x.toFixed(1)}, ${penStart.y.toFixed(1)}   start node: #${penStartNodeId}`);
        g.setPointerCapture && g.setPointerCapture(ev.pointerId);
        return;
      }

      ev.preventDefault(); ev.stopPropagation();
      dragging = true; g.setPointerCapture(ev.pointerId);
      dragStart = {x:ev.clientX, y:ev.clientY};
      orig = {x:n.x, y:n.y};
    });
    g.addEventListener('pointermove', (ev) => {
      if (!dragging) return;
      if (penModeActive) return;
      const rect = svg.getBoundingClientRect();
      const dx = (ev.clientX - dragStart.x) * (viewBox.w / rect.width);
      const dy = (ev.clientY - dragStart.y) * (viewBox.h / rect.height);
      const nx = orig.x + dx;
      const ny = orig.y + dy;
      g.setAttribute('transform', `translate(${nx}, ${ny})`);
    });
    g.addEventListener('pointerup', async (ev) => {
      if (penModeActive && penDrawing) {
        g.releasePointerCapture && g.releasePointerCapture(ev.pointerId);
        return;
      }
      if (!dragging) return;
      dragging = false; g.releasePointerCapture(ev.pointerId);
      const rect = svg.getBoundingClientRect();
      const dx = (ev.clientX - dragStart.x) * (viewBox.w / rect.width);
      const dy = (ev.clientY - dragStart.y) * (viewBox.h / rect.height);
      const nx = orig.x + dx;
      const ny = orig.y + dy;
      await fetch(`/api/nodes/${id}`, {
        method: 'PUT',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({ x: nx, y: ny })
      });
      await loadData();
    });

    nodesG.appendChild(g);
  }
}

function renderConnections() {
  connsG.innerHTML = '';
  for (const [id, c] of connsMap.entries()) {
    const s = nodesMap.get(c.source);
    const t = nodesMap.get(c.target);
    if (!s || !t) continue;
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', s.x); line.setAttribute('y1', s.y);
    line.setAttribute('x2', t.x); line.setAttribute('y2', t.y);
    line.setAttribute('stroke', '#cbe4ff'); line.setAttribute('stroke-width', 2);
    line.setAttribute('marker-end', 'url(#arrow)');
    line.setAttribute('data-id', id);
    line.setAttribute('data-src', c.source);
    line.setAttribute('data-tgt', c.target);
    if (playingPathEdgeIds && playingPathEdgeIds.has(Number(id))) {
      line.setAttribute('stroke', '#2ecc71');
      line.setAttribute('stroke-width', 4);
      line.style.opacity = 1.0;
    } else {
      line.style.opacity = 0.85;
    }
    connsG.appendChild(line);
  }
}

function renderAll() {
  renderConnections();
  renderNodes();
  updateSelectedUI();
}

// ---------- Selection & interactions ----------

function onNodeClick(ev, id) {
  ev.stopPropagation();
  if (shiftPressed && selectedNodeId && Number(selectedNodeId) !== Number(id)) {
    createConnection(selectedNodeId, id);
    topBanner.style.display = 'none';
    shiftPressed = false;
    return;
  }
  selectNode(id);
}

function selectNode(id) {
  selectedNodeId = id;
  if (!isPlaying) playingNodeId = null;
  updateSelectedUI();
  renderAll();
}

function updateSelectedUI() {
  const title = document.getElementById('nodeTitle');
  const idEl = document.getElementById('nodeId');
  const posEl = document.getElementById('nodePos');
  const created = document.getElementById('nodeCreated');
  const desc = document.getElementById('nodeDesc');
  if (!selectedNodeId) {
    title.textContent = 'No node selected';
    idEl.textContent = '—';
    posEl.textContent = '—';
    created.textContent = '—';
    desc.textContent = '—';
    document.getElementById('openUpdateBtn').style.display='none';
    document.getElementById('createBranchBtn').style.display='none';
    return;
  }
  const n = nodesMap.get(selectedNodeId);
  if (!n) return;
  title.textContent = `#${n.id} — ${n.name}`;
  idEl.textContent = n.id;
  posEl.textContent = `${(Number(n.x)||0).toFixed(1)}, ${(Number(n.y)||0).toFixed(1)}`;
  created.textContent = n.created_at || '—';
  desc.textContent = n.description || '—';
  document.getElementById('openUpdateBtn').style.display='block';
  document.getElementById('createBranchBtn').style.display='block';
  if (n.text) showLongText(`#${n.id} — ${n.name}`, n.text);
  else hideLongText();
}

// ---------- Create / Update / Branch / Generate wiring ----------

const modalUpdate = document.getElementById('modal-update');
document.getElementById('openUpdateBtn').addEventListener('click', async () => {
  if (!selectedNodeId) return alert("No node selected");
  openUpdateModal(selectedNodeId, { focusFirst: true });
});
async function openUpdateModal(id, opts={ focusFirst:false }) {
  const r = await fetch(`/api/nodes/${id}`);
  if (!r.ok) return alert("Failed to fetch node");
  const node = await r.json();
  document.getElementById('updNodeLabel').textContent = `#${node.id}`;
  document.getElementById('updName').value = node.name || '';
  document.getElementById('updDesc').value = node.description || '';
  document.getElementById('updText').value = node.text || '';
  document.getElementById('updCoords').value = `${node.x || 0}, ${node.y || 0}`;
  modalUpdate.style.display = 'flex';
  // attach a temporary key handler so ENTER triggers save
  function onKey(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      document.getElementById('submitUpdate').click();
    }
    if (e.key === 'Escape') {
      modalUpdate.style.display = 'none';
    }
  }
  window.addEventListener('keydown', onKey);
  // when modal closed, remove the listener
  const observer = new MutationObserver(() => {
    if (modalUpdate.style.display !== 'flex') {
      window.removeEventListener('keydown', onKey);
      observer.disconnect();
    }
  });
  observer.observe(modalUpdate, { attributes: true, attributeFilter: ['style'] });
}
document.getElementById('cancelUpdate').addEventListener('click', () => { modalUpdate.style.display = 'none'; });
document.getElementById('submitUpdate').addEventListener('click', async () => {
  if (!selectedNodeId) { modalUpdate.style.display = 'none'; return; }
  const name = document.getElementById('updName').value || 'Node';
  const desc = document.getElementById('updDesc').value || null;
  const text = document.getElementById('updText').value || null;
  const coordsRaw = document.getElementById('updCoords').value.trim();
  const payload = { name, description: desc, text };
  if (coordsRaw) {
    const parts = coordsRaw.split(',').map(p => parseFloat(p.trim()));
    if (parts.length === 2 && parts.every(p => !Number.isNaN(p))) {
      payload.x = parts[0]; payload.y = parts[1];
    }
  }
  const r = await fetch(`/api/nodes/${selectedNodeId}`, { method: 'PUT', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload)});
  if (!r.ok) {
    const txt = await r.text();
    alert('Error updating: ' + txt);
  } else {
    modalUpdate.style.display = 'none';
    await loadData();
  }
});

// Create button opens the standard modal (create via server)
document.getElementById('createBtn').addEventListener('click', async () => {
  // Simple create modal: prefill then show modalUpdate as "create" flow is separate — keep minimal
  document.getElementById('updNodeLabel').textContent = '';
  document.getElementById('updName').value = 'Node';
  document.getElementById('updDesc').value = '';
  document.getElementById('updText').value = '';
  document.getElementById('updCoords').value = '0, 0';
  // We'll show the create modal as an entry point; but actual creation handled by separate modal in original UI
  // For brevity, open the create modal by reusing create modal flow — kept minimal for this update
  const name = prompt('Create node name', 'Node');
  if (!name) return;
  const payload = { name };
  const r = await fetch('/api/nodes', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload) });
  if (!r.ok) alert('Failed to create node'); else { await loadData(); }
});

// GENERATE modal
const modalGen = document.getElementById('modal-gen');
document.getElementById('genBtn').addEventListener('click', () => modalGen.style.display = 'flex');
document.getElementById('cancelGen').addEventListener('click', () => modalGen.style.display = 'none');
document.getElementById('submitGen').addEventListener('click', async () => {
  const count = parseInt(document.getElementById('genCount').value || '0', 10);
  if (!count || count <= 0) { alert('Enter a valid positive number'); return; }
  const r = await fetch('/api/generate_random', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ count }) });
  if (r.status === 201) {
    modalGen.style.display = 'none';
    loadData();
  } else {
    const txt = await r.text();
    alert('Error generating graph: ' + txt);
  }
});

// admin & clear wiring
document.getElementById('adminBtn').addEventListener('click', () => { window.location.href = '/admin'; });
const clearSceneBtn = document.getElementById('clearBtn');
function updateClearSceneButton(nodes) {
  if (Array.isArray(nodes) && nodes.length > 0) clearSceneBtn.disabled = false;
  else clearSceneBtn.disabled = true;
}
clearSceneBtn.addEventListener('click', async () => {
  const ok = confirm('Delete all nodes and connections from the scene? This will clear the database. Are you sure?');
  if (!ok) return;
  const typed = prompt('Type DELETE to confirm clearing the entire database.');
  if (typed !== 'DELETE') { alert('Confirmation mismatch — aborted.'); return; }
  try {
    const resp = await fetch('/api/admin/clear', { method: 'POST' });
    if (resp.ok) {
      await loadData();
      selectNode(null);
      alert('Scene cleared.');
    } else {
      const txt = await resp.text();
      alert('Failed to clear scene: ' + txt);
    }
  } catch (err) {
    alert('Error clearing scene: ' + err);
  }
});

// Quick select
document.getElementById('quickSelectBtn').addEventListener('click', async () => {
  const raw = document.getElementById('quickSelectId').value.trim();
  if (!raw) return;
  const m = raw.match(/^#\s*([0-9]+)$/) || raw.match(/^([0-9]+)$/);
  if (!m) return alert('Enter an ID in the form #123 or 123');
  const id = parseInt(m[1], 10);
  if (!nodesMap.has(id)) await loadData();
  const n = nodesMap.get(id);
  if (n) {
    animateViewTo(n.x, n.y, () => selectNode(id));
  } else {
    alert('Node not found');
  }
});

function populateAllNodesList(nodes) {
  const all = document.getElementById('allNodesList');
  if (!nodes || !nodes.length) { all.innerHTML = '<div class="muted-block">No nodes</div>'; return; }
  all.innerHTML = nodes.map(n => `<div style="padding:6px 0; border-bottom:1px dashed rgba(255,255,255,0.03)"><a href="#" onclick="(async()=>{ animateViewTo(${n.x},${n.y}); selectNode(${n.id}); })(); return false;" style="color:#cfe3ff; text-decoration:none;">#${n.id} — ${escapeHtml(n.name||'')}</a><div class="muted-block">${escapeHtml((n.description||'').slice(0,120))}</div></div>`).join('');
}

function animateViewTo(cx, cy, done=null) {
  const start = Object.assign({}, viewBox);
  const targetW = viewBox.w * 0.6;
  const targetH = viewBox.h * 0.6;
  const target = { x: cx - targetW/2, y: cy - targetH/2, w: targetW, h: targetH };
  const t0 = performance.now();
  const duration = 600;
  function step(now) {
    const t = Math.min(1, (now - t0) / duration);
    const ease = t*(2-t);
    viewBox.x = start.x + (target.x - start.x) * ease;
    viewBox.y = start.y + (target.y - start.y) * ease;
    viewBox.w = start.w + (target.w - start.w) * ease;
    viewBox.h = start.h + (target.h - start.h) * ease;
    setViewBox();
    if (t < 1) requestAnimationFrame(step);
    else if (done) done();
  }
  requestAnimationFrame(step);
}

// create connection
async function createConnection(src, tgt) {
  const r = await fetch('/api/connections', {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify({ source: parseInt(src), target: parseInt(tgt) })
  });
  if (r.status === 201) {
    await loadData();
    selectNode(tgt);
  } else {
    const txt = await r.text();
    alert('Failed to create connection: ' + txt);
  }
}

// fit & toggle long text
document.getElementById('fitBtn').addEventListener('click', () => {
  if (!nodesMap.size) return;
  let minx=1e9, miny=1e9, maxx=-1e9, maxy=-1e9;
  for (const n of nodesMap.values()) {
    minx = Math.min(minx, n.x); miny = Math.min(miny, n.y);
    maxx = Math.max(maxx, n.x); maxy = Math.max(maxy, n.y);
  }
  const padding = 120;
  const w = (maxx - minx) + padding*2;
  const h = (maxy - miny) + padding*2;
  viewBox = { x: minx - padding, y: miny - padding, w, h };
  setViewBox();
});
document.getElementById('toggleLong').addEventListener('click', () => {
  longtext.style.display = (longtext.style.display === 'block') ? 'none' : 'block';
});

function showLongText(title, txt) {
  longtext.innerHTML = `<h3 style="margin:0 0 6px 0;">${escapeHtml(title)}</h3><div style="white-space:pre-wrap">${escapeHtml(txt)}</div>`;
  longtext.style.display = 'block';
}
function hideLongText() { longtext.style.display = 'none'; }







// ---------- Play / Pause (replacement) ----------

playBtn.addEventListener('click', async () => {
  if (isPlaying) {
    stopPlaying();
  } else {
    let rootId = null;
    if (selectedNodeId) {
      rootId = findRoot(selectedNodeId);
    } else {
      for (const n of nodesMap.values()) {
        const inc = getIncoming(n.id);
        if (!inc || inc.length === 0) { rootId = n.id; break; }
      }
      if (rootId === null && nodesMap.size > 0) rootId = Array.from(nodesMap.keys())[0];
    }
    if (!rootId) return alert('No nodes to play.');
    const pathNodes = traceSequenceFromRoot(rootId);
    if (!pathNodes || pathNodes.length === 0) return alert('No sequence path found to play.');
    startPlayingPath(pathNodes);
  }
});

// helper UI: top-centered play banner (creates if missing)
function ensurePlayBanner() {
  let banner = document.getElementById('playTextBanner');
  if (!banner) {
    banner = document.createElement('div');
    banner.id = 'playTextBanner';
    banner.style.position = 'absolute';
    banner.style.left = '50%';
    banner.style.transform = 'translateX(-50%)';
    banner.style.top = '8px';
    banner.style.zIndex = 9999;
    banner.style.padding = '12px 20px';
    banner.style.background = 'rgba(0,0,0,0.72)';
    banner.style.color = '#eaf6ff';
    banner.style.borderRadius = '8px';
    banner.style.fontSize = '16px';
    banner.style.fontWeight = '700';
    banner.style.maxWidth = '70%';
    banner.style.textAlign = 'center';
    banner.style.pointerEvents = 'none';
    banner.style.boxShadow = '0 8px 30px rgba(0,0,0,0.6)';
    banner.style.whiteSpace = 'pre-wrap';
    document.getElementById('svgWrap').appendChild(banner);
  }
  return banner;
}

function showPlayBanner(text) {
  const banner = ensurePlayBanner();
  // prefer node.text but fallback to name
  banner.textContent = text || '';
  banner.style.display = 'block';
}

function hidePlayBanner() {
  const banner = document.getElementById('playTextBanner');
  if (banner) banner.style.display = 'none';
}

// ---------- startPlayingPath (preserve whitespace + live textarea regeneration) ----------
function startPlayingPath(pathNodes) {
  playingPathEdgeIds = new Set(edgesForPathNodes(pathNodes).map(x => Number(x)));
  isPlaying = true;
  playBtn.textContent = 'Pause ⏸';
  renderAll();

  // ensure banner (top-centered) exists and is set to preserve whitespace
  function ensurePlayBannerAndArea() {
    let banner = document.getElementById('playTextBanner');
    if (!banner) {
      banner = document.createElement('div');
      banner.id = 'playTextBanner';
      banner.style.position = 'absolute';
      banner.style.left = '50%';
      banner.style.transform = 'translateX(-50%)';
      banner.style.top = '8px';
      banner.style.zIndex = 9999;
      banner.style.padding = '10px 16px';
      banner.style.background = 'rgba(0,0,0,0.72)';
      banner.style.color = '#eaf6ff';
      banner.style.borderRadius = '8px';
      banner.style.fontSize = '15px';
      banner.style.fontWeight = '700';
      banner.style.maxWidth = '80%';
      banner.style.textAlign = 'left';
      banner.style.pointerEvents = 'none';
      banner.style.boxShadow = '0 8px 30px rgba(0,0,0,0.6)';
      // preserve whitespace and newlines
      banner.style.whiteSpace = 'pre-wrap';
      banner.style.wordBreak = 'break-word';
      document.getElementById('svgWrap').appendChild(banner);
    }

    let area = document.getElementById('playAccumTextArea');
    if (!area) {
      area = document.createElement('textarea');
      area.id = 'playAccumTextArea';
      area.readOnly = true;
      area.style.position = 'absolute';
      area.style.left = '50%';
      area.style.transform = 'translateX(-50%)';
      // place slightly below banner
      area.style.top = '56px';
      area.style.zIndex = 9998;
      area.style.width = '80%';
      area.style.height = '140px';
      area.style.padding = '10px';
      area.style.background = 'rgba(6,10,14,0.95)';
      area.style.color = '#eaf6ff';
      area.style.border = '1px solid rgba(255,255,255,0.06)';
      area.style.borderRadius = '8px';
      area.style.fontFamily = 'monospace';
      area.style.fontSize = '13px';
      area.style.boxShadow = '0 8px 30px rgba(0,0,0,0.6)';
      // show newlines naturally
      area.style.whiteSpace = 'pre-wrap';
      area.style.overflow = 'auto';
      document.getElementById('svgWrap').appendChild(area);
    }

    // show them
    banner.style.display = 'block';
    area.style.display = 'block';
    return { banner, area };
  }

  const { banner, area } = ensurePlayBannerAndArea();

  // accumulate banner text progressively, preserving whitespace
  let accumulatedText = '';
  let idx = 0;
  const total = pathNodes.length;

  const stepLoop = async () => {
    while (isPlaying && idx < total) {
      const node = pathNodes[idx];
      playingNodeId = Number(node.id);

      // update UI selection
      selectNode(node.id);

      // pick token: prefer node.text; fallback to node.name
      let token = '';
      if (node && node.text !== undefined && node.text !== null && String(node.text).length > 0) {
        token = String(node.text);
      } else {
        token = String(node.name || '');
      }

      // IMPORTANT: preserve token verbatim (including leading/trailing whitespace/newlines)
      // When joining tokens, decide whether to add an extra space between tokens:
      // - If accumulatedText is empty -> set directly to token.
      // - Else if token starts with whitespace (/\s/) -> append token as-is (preserve spacing/newlines).
      // - Else if accumulatedText ends with whitespace -> append token as-is.
      // - Else append a single space then token (to separate words).
      if (accumulatedText.length === 0) {
        accumulatedText = token;
      } else if (/^[\s]/.test(token) || /[\s]$/.test(accumulatedText)) {
        accumulatedText += token;
      } else {
        accumulatedText += ' ' + token;
      }

      // update banner and textarea (banner shows a trimmed preview if very long; textarea shows full content)
      // banner will show the most recent part but keep newlines intact
      const previewMax = 800; // max chars to show in banner (protect UI)
      let bannerText = accumulatedText;
      if (bannerText.length > previewMax) {
        // show last portion (preserve leading newline context)
        bannerText = '…' + bannerText.slice(-previewMax);
      }
      // add progress marker
      banner.textContent = bannerText + ` (${idx+1}/${total})`;

      // update textarea with full accumulated text (preserve newlines)
      area.value = accumulatedText;
      // autoscroll to bottom
      area.scrollTop = area.scrollHeight;

      // wait interval or until stopped
      await new Promise(res => {
        playTimeout = setTimeout(res, playIntervalMs);
      });

      idx++;
    }

    // when finished or stopped, keep area visible but hide banner after a short delay
    // hide banner to reduce UI clutter, keep textarea for inspection
    setTimeout(() => {
      const b = document.getElementById('playTextBanner');
      if (b) b.style.display = 'none';
    }, 400);

    stopPlaying();
  };

  stepLoop().catch(err => { console.error(err); stopPlaying(); });
}


// ---------- stopPlaying (replacement) ----------
function stopPlaying() {
  isPlaying = false;
  playingNodeId = null;
  playingPathEdgeIds = new Set();
  if (playTimeout) { clearTimeout(playTimeout); playTimeout = null; }
  playBtn.textContent = 'Play ▶';
  hidePlayBanner();
  renderAll();
}



/*
// ---------- PLAY / PAUSE handlers ----------

playBtn.addEventListener('click', async () => {
  if (isPlaying) {
    stopPlaying();
  } else {
    let rootId = null;
    if (selectedNodeId) {
      rootId = findRoot(selectedNodeId);
    } else {
      for (const n of nodesMap.values()) {
        const inc = getIncoming(n.id);
        if (!inc || inc.length === 0) { rootId = n.id; break; }
      }
      if (rootId === null && nodesMap.size > 0) rootId = Array.from(nodesMap.keys())[0];
    }
    if (!rootId) return alert('No nodes to play.');
    const pathNodes = traceSequenceFromRoot(rootId);
    if (!pathNodes || pathNodes.length === 0) return alert('No sequence path found to play.');
    startPlayingPath(pathNodes);
  }
});

function startPlayingPath(pathNodes) {
  playingPathEdgeIds = new Set(edgesForPathNodes(pathNodes).map(x => Number(x)));
  isPlaying = true;
  playBtn.textContent = 'Pause ⏸';
  renderAll();
  let idx = 0;
  const stepLoop = async () => {
    while (isPlaying && idx < pathNodes.length) {
      const node = pathNodes[idx];
      playingNodeId = Number(node.id);
      selectNode(node.id);
      await new Promise(res => {
        playTimeout = setTimeout(res, playIntervalMs);
      });
      idx++;
    }
    stopPlaying();
  };
  stepLoop().catch(err => { console.error(err); stopPlaying(); });
}

function stopPlaying() {
  isPlaying = false;
  playingNodeId = null;
  playingPathEdgeIds = new Set();
  if (playTimeout) { clearTimeout(playTimeout); playTimeout = null; }
  playBtn.textContent = 'Play ▶';
  renderAll();
}
*/

// ---------- Data loading ----------

async function loadData() {
  const nodesResp = await fetch('/api/nodes');
  const connsResp = await fetch('/api/connections');
  const nodes = await nodesResp.json();
  const conns = await connsResp.json();
  nodesMap.clear(); connsMap.clear();
  nodes.forEach(n => nodesMap.set(n.id, n));
  conns.forEach(c => connsMap.set(c.id, c));
  renderAll();
  populateAllNodesList(nodes);
  updateClearSceneButton(nodes);
}
function updateClearSceneButton(nodes) {
  document.getElementById('clearBtn').disabled = !(Array.isArray(nodes) && nodes.length>0);
}

// initial load
loadData();

// expose for debugging / inline usage
window.selectNode = selectNode;
window.openUpdateModal = openUpdateModal;
window.traceSequenceFromRoot = traceSequenceFromRoot;
window.findRoot = findRoot;

/* ---------- ANALYZE PATH TOOL (simulation-only; prints logs; does NOT write DB) ---------- */

// helper: find a directed path (BFS) from startId to targetId; returns array of node IDs or null
function findDirectedPath(startId, targetId) {
  const q = [[startId]];
  const seen = new Set([startId]);
  while (q.length) {
    const path = q.shift();
    const last = path[path.length-1];
    if (Number(last) === Number(targetId)) return path.map(Number);
    const outs = getOutgoing(last);
    for (const o of outs) {
      const nxt = Number(o.target);
      if (seen.has(nxt)) continue;
      seen.add(nxt);
      q.push(path.concat([nxt]));
    }
  }
  return null;
}

/*
// analyzeLayout: starting from selected node (or require selection), compute root, trace, ask user for target, simulate description edits, log everything
async function analyzeLayoutFromSelected() {
  if (!selectedNodeId) return alert('Select a node first (click on the graph) to analyze the layout.');
  addPenLog(`ANALYSIS started (initiated by click / Analyze button). Selected node: #${selectedNodeId}`);
  const root = findRoot(selectedNodeId);
  addPenLog(`Determined root node for playback: #${root}`);
  const trace = traceSequenceFromRoot(root);
  addPenLog(`Current playback trace from root (ids): ${trace.map(n => '#' + n.id).join(' -> ')}`);
  if (trace.length === 0) {
    addPenLog('Trace is empty — nothing to analyze further.');
    return;
  }
  const currentEnd = trace[trace.length-1].id;
  addPenLog(`Current playback end node is #${currentEnd}`);

  // prompt user for desired target
  // build list text
  const nodeListText = Array.from(nodesMap.values()).map(n => `#${n.id}: ${n.name || ''}`).join('\n');
  const promptMsg = `Enter the target node ID (numeric) to which you want playback to lead.\n\nAvailable nodes:\n${nodeListText}\n\nExample: enter 13`;
  const raw = prompt(promptMsg, '');
  if (!raw) { addPenLog('User cancelled target selection. Analysis aborted.'); return; }
  const m = raw.match(/^#?\s*([0-9]+)$/);
  if (!m) { addPenLog(`Invalid input for target: "${raw}". Aborting.`); return; }
  const targetId = Number(m[1]);
  if (!nodesMap.has(targetId)) { addPenLog(`Target node #${targetId} not found in graph. Aborting.`); return; }
  addPenLog(`User selected target node #${targetId}`);

  // quick check: is there already a directed path from root -> target ?
  const existingPath = findDirectedPath(root, targetId);
  if (existingPath) {
    addPenLog(`Existing directed path from root -> target found: ${existingPath.map(x=>'#'+x).join(' -> ')}`);
    // if the existing path already matches the intended target, report and finish
    if (existingPath[existingPath.length-1] === targetId) {
      addPenLog('Playback already can reach the target. No changes required.');
      return;
    }
  } else {
    addPenLog('No existing directed path from root to target found. Will attempt to simulate description edits to steer playback where possible.');
  }

  // We'll simulate: compute the sequence path we want (prefer shortest from root -> target using BFS)
  const desiredPath = findDirectedPath(root, targetId);
  if (!desiredPath) {
    addPenLog(`No possible path exists via current connections (root #${root} -> target #${targetId}). Without creating new connections, steering is impossible. Analysis complete.`);
    return;
  }
  addPenLog(`Desired route (shortest) to make playback reach target: ${desiredPath.map(i => '#'+i).join(' -> ')}`);

  // We'll simulate in-memory description edits:
  const originalDescriptions = new Map();
  for (const id of desiredPath) {
    const n = nodesMap.get(Number(id));
    originalDescriptions.set(Number(id), n.description);
  }

  addPenLog(`Simulating description edits (no DB writes). Will update each parent node's description on the path to explicitly reference the next node's ID using "#<id>" tokens.`);

  let editCount = 0;
  const simulationLogs = [];
  // For each step along desiredPath except final (target), ensure the node description includes "#next"
  for (let i = 0; i < desiredPath.length - 1; i++) {
    const thisId = Number(desiredPath[i]);
    const nextId = Number(desiredPath[i+1]);
    const node = nodesMap.get(thisId);
    const oldDesc = node.description || '';
    // If already contains nextId, skip
    if ((oldDesc || '').match(new RegExp('\\#\\s*' + nextId + '\\b'))) {
      simulationLogs.push(`Node #${thisId}: already references #${nextId} in description. No edit needed.`);
      continue;
    }
    const newDesc = (oldDesc ? (oldDesc + ' ') : '') + `Follow #${nextId}`;
    // simulate change in memory
    nodesMap.get(thisId).description = newDesc;
    editCount++;
    simulationLogs.push(`Node #${thisId}: description changed (simulated). OLD: "${oldDesc}" => NEW: "${newDesc}"`);
    // after each change, optionally test by tracing sequence from root to see if the playback so far will follow towards target
    const testTrace = traceSequenceFromRoot(root).map(n => Number(n.id));
    simulationLogs.push(`  After simulated edit, trace from root is now: ${testTrace.map(x=>'#'+x).join(' -> ')}`);
    // if trace already ends at target, we can break early
    if (testTrace[testTrace.length - 1] === targetId) {
      simulationLogs.push(`  Trace now reaches target #${targetId} after ${editCount} simulated edits. Stopping simulation.`);
      break;
    }
  }

  // finalize logs: restore original descriptions (we never write to DB)
  for (const [id, desc] of originalDescriptions.entries()) {
    nodesMap.get(Number(id)).description = desc;
  }

  addPenLog('--- ANALYSIS LOG BEGIN ---');
  addPenLog(`Root: #${root}`);
  addPenLog(`Original playback end: #${currentEnd}`);
  addPenLog(`Target requested: #${targetId}`);
  addPenLog(`Desired path: ${desiredPath.map(x=>'#'+x).join(' -> ')}`);
  for (const s of simulationLogs) addPenLog(s);
  addPenLog(`Total simulated description edits required (count): ${editCount}`);
  addPenLog('NOTE: No database writes were performed. This was a simulation. To apply these changes, send the planned updates for the nodes to the API (PUT /api/nodes/<id>) with the new description text.');
  addPenLog('--- ANALYSIS LOG END ---');
}
*/

async function analyzeAndSetSequenceEnd() {
  // Ensure a node is selected (we need a context to compute root)
  if (!selectedNodeId) {
    alert('Please select a node first (this determines the root for the sequence analysis).');
    return;
  }

  addPenLog(`ANALYSIS: starting sequence analysis for selected node #${selectedNodeId}`);

  // 1) Compute the root and current sequence like PLAY does
  const root = findRoot(selectedNodeId);
  addPenLog(`ANALYSIS: computed root = #${root}`);

  // traceSequenceFromRoot returns array of node objects
  const currentSequence = traceSequenceFromRoot(root).map(n => Number(n.id));
  addPenLog(`ANALYSIS: current sequence from root: ${currentSequence.map(i => '#' + i).join(' -> ')}`);

  if (!currentSequence || currentSequence.length === 0) {
    addPenLog('ANALYSIS: no sequence path found from root — cannot continue.');
    return;
  }

  // 2) Ask the user to choose desired end node
  // show a quick list of nodes (id + name + description truncated)
  const nodeLines = Array.from(nodesMap.values())
    .sort((a,b) => Number(a.id)-Number(b.id))
    .map(n => `#${n.id} — ${n.name || '(no name)'} — ${((n.description||'')+'').slice(0,80)}`)
    .join('\n');

  const rawTarget = prompt(`Enter the numeric ID of the node you want the sequence to end at.\nAvailable nodes:\n${nodeLines}\n\nExample: 13`, '');
  if (!rawTarget) {
    addPenLog('ANALYSIS: user cancelled target selection.');
    return;
  }
  const m = rawTarget.match(/^#?\s*([0-9]+)$/);
  if (!m) {
    addPenLog(`ANALYSIS: invalid target input "${rawTarget}". Aborting.`);
    alert('Invalid node id. Aborting analysis.');
    return;
  }
  const targetId = Number(m[1]);
  if (!nodesMap.has(targetId)) {
    addPenLog(`ANALYSIS: target #${targetId} not found in nodesMap. Aborting.`);
    alert(`Node #${targetId} not found.`);
    return;
  }
  addPenLog(`ANALYSIS: user selected target #${targetId}`);

  // 3) Find a shortest directed path from root -> target using BFS
  function findDirectedPath(startId, targetId) {
    const q = [[Number(startId)]];
    const seen = new Set([Number(startId)]);
    while (q.length) {
      const path = q.shift();
      const last = Number(path[path.length - 1]);
      if (last === Number(targetId)) return path.map(Number);
      const outs = getOutgoing(last);
      for (const o of outs) {
        const nxt = Number(o.target);
        if (seen.has(nxt)) continue;
        seen.add(nxt);
        q.push(path.concat([nxt]));
      }
    }
    return null;
  }

  const desiredPath = findDirectedPath(root, targetId);
  if (!desiredPath) {
    addPenLog(`ANALYSIS: no directed path exists from root #${root} to target #${targetId}. Cannot reach target with existing connections.`);
    alert(`No path from root (#${root}) to target (#${targetId}). You would need to create connections first.`);
    return;
  }
  addPenLog(`ANALYSIS: desired path (root -> target) = ${desiredPath.map(i => '#' + i).join(' -> ')}`);

  // 4) Simulate edits to descriptions along desiredPath (except last)
  // Save original descriptions so we can restore if needed
  const originalDescriptions = new Map();
  for (const id of desiredPath) {
    const n = nodesMap.get(Number(id));
    originalDescriptions.set(Number(id), n ? n.description : null);
  }

  addPenLog('ANALYSIS: simulating description edits to steer playback along the desired path.');
  // Plan: for each node in desiredPath except final, ensure description refers to next node
  const plannedEdits = []; // { id, oldDesc, newDesc }
  for (let i = 0; i < desiredPath.length - 1; i++) {
    const thisId = Number(desiredPath[i]);
    const nextId = Number(desiredPath[i+1]);
    const node = nodesMap.get(thisId);
    if (!node) continue;
    const oldDesc = node.description || '';

    // If oldDesc already references the desired nextId, skip
    const re = new RegExp('\\#\\s*' + nextId + '\\b');
    if (oldDesc.match(re)) {
      addPenLog(`ANALYSIS: node #${thisId} already references #${nextId} — no edit planned.`);
      continue;
    }

    // If description contains any #<num> token, replace the *first* occurrence with nextId
    const anyHashRe = /\#\s*([0-9]+)/;
    let newDesc;
    if (anyHashRe.test(oldDesc)) {
      newDesc = oldDesc.replace(anyHashRe, `#${nextId}`);
    } else {
      // otherwise append an explicit steering token
      newDesc = (oldDesc ? (oldDesc + ' ') : '') + `Follow #${nextId}`;
    }

    plannedEdits.push({ id: thisId, oldDesc, newDesc });
    // apply to in-memory nodesMap so we can re-trace after each simulated edit
    nodesMap.get(thisId).description = newDesc;

    // re-evaluate the trace after this simulated edit
    const testTrace = traceSequenceFromRoot(root).map(n => Number(n.id));
    addPenLog(`ANALYSIS: after simulating edit on #${thisId} -> trace now: ${testTrace.map(x=>'#'+x).join(' -> ')}`);
    if (testTrace.length && testTrace[testTrace.length - 1] === targetId) {
      addPenLog(`ANALYSIS: trace now reaches the target (#${targetId}) after simulated edits up to node #${thisId}.`);
      break; // stop simulating further edits
    }
  }

  if (plannedEdits.length === 0) {
    addPenLog('ANALYSIS: no description edits were required (playback already reaches target).');
    alert('Playback already reaches the target. No description changes required.');
    // restore any potentially overridden descriptions (safety)
    for (const [id, desc] of originalDescriptions.entries()) {
      nodesMap.get(Number(id)).description = desc;
    }
    return;
  }

  // Build summary to show to user
  const summary = plannedEdits.map(e => `#${e.id}:\n  OLD: "${e.oldDesc}"\n  NEW: "${e.newDesc}"`).join('\n\n');
  const confirmMsg = `Planned description edits to steer playback to #${targetId} (root #${root}):\n\n${summary}\n\nApply these edits to the server? (OK = apply, Cancel = do NOT apply)`;
  const doApply = confirm(confirmMsg);

  if (!doApply) {
    addPenLog('ANALYSIS: user cancelled apply. Restoring in-memory descriptions. No DB writes occurred.');
    // restore original descriptions in memory
    for (const [id, desc] of originalDescriptions.entries()) {
      if (nodesMap.has(Number(id))) nodesMap.get(Number(id)).description = desc;
    }
    return;
  }

  // 5) Apply changes via API PUT requests (sequentially), update nodesMap and log results
  addPenLog(`ANALYSIS: applying ${plannedEdits.length} description edits to server...`);
  let successCount = 0;
  for (const edit of plannedEdits) {
    try {
      const body = { description: edit.newDesc };
      addPenLog(`ANALYSIS: PUT /api/nodes/${edit.id}  payload: ${JSON.stringify(body)}`);
      const resp = await fetch(`/api/nodes/${edit.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });
      if (!resp.ok) {
        const txt = await resp.text();
        addPenLog(`ANALYSIS: failed to update #${edit.id}: ${resp.status} ${txt}`);
      } else {
        successCount++;
        addPenLog(`ANALYSIS: successfully updated #${edit.id}`);
        // update local cache if server returns the updated node
        try {
          const updated = await resp.json();
          if (updated && updated.id) nodesMap.set(Number(updated.id), updated);
        } catch (e) {
          // fallback: if no json returned, set description locally
          if (nodesMap.has(Number(edit.id))) nodesMap.get(Number(edit.id)).description = edit.newDesc;
        }
      }
    } catch (err) {
      addPenLog(`ANALYSIS: network error updating #${edit.id}: ${err}`);
    }
  }

  addPenLog(`ANALYSIS: applied ${successCount} / ${plannedEdits.length} edits. Refreshing data...`);

  // 6) Reload data and show final trace
  await loadData();
  const finalTrace = traceSequenceFromRoot(root).map(n => Number(n.id));
  addPenLog(`ANALYSIS: final trace after applying edits: ${finalTrace.map(x=>'#'+x).join(' -> ')}`);
  const finalEnd = finalTrace.length ? finalTrace[finalTrace.length - 1] : null;
  addPenLog(`ANALYSIS: final end node = ${finalEnd ? '#'+finalEnd : '(none)'}`);
  if (finalEnd === targetId) {
    addPenLog(`ANALYSIS: SUCCESS — playback now reaches target #${targetId}.`);
    // select the newly reached target for convenience
    selectNode(targetId);
  } else {
    addPenLog('ANALYSIS: WARNING — final trace did not reach the requested target. You may need additional edits deeper in the path or to create new connections.');
  }

  // done
}



// hook Analyze button
analyzeBtn.addEventListener('click', () => {
  // require a selected node (user clicks node first)
  if (!selectedNodeId) {
    alert('Please select a node (click on it) before running Analyze Path.');
    return;
  }
  //analyzeLayoutFromSelected();
  analyzeAndSetSequenceEnd();
});


/*
// ---------- Build graph from pasted text ----------

document.getElementById('textGraphBtn').addEventListener('click', () => {
  // open modal
  const m = document.getElementById('modal-textgraph');
  if (m) m.style.display = 'flex';
  const ta = document.getElementById('textGraphArea');
  if (ta) ta.value = '';
  // focus textarea next event loop
  setTimeout(() => ta && ta.focus(), 50);
});

document.getElementById('textGraphCancel').addEventListener('click', () => {
  const m = document.getElementById('modal-textgraph');
  if (m) m.style.display = 'none';
});

// Helper: extract words from arbitrary text (Unicode letters/numbers, keeps apostrophes/hyphens)
function extractWordsFromText(text) {
  if (!text) return [];
  // Normalize whitespace and split; remove punctuation except internal apostrophes/hyphens
  // Uses Unicode-aware class for letters/numbers where supported.
  try {
    // prefer Unicode property escape if available
    const raw = text.trim();
    // Split on whitespace and punctuation, then clean tokens
    const tokens = raw.split(/\s+/);
    const words = tokens.map(w => w.replace(/[^\p{L}\p{N}'\-]+/gu, '')).filter(Boolean);
    return words;
  } catch (e) {
    // fallback for environments that do not support \p{}:
    const raw = text.trim();
    const tokens = raw.split(/\s+/);
    const words = tokens.map(w => w.replace(/[^A-Za-z0-9'\-]+/g, '')).filter(Boolean);
    return words;
  }
}

document.getElementById('textGraphGenerate').addEventListener('click', async () => {
  const m = document.getElementById('modal-textgraph');
  const ta = document.getElementById('textGraphArea');
  if (!ta || !m) return;
  const txt = ta.value.trim();
  if (!txt) { alert('Paste some text first'); return; }
  // disable buttons while generating
  const genBtn = document.getElementById('textGraphGenerate');
  const cancelBtn = document.getElementById('textGraphCancel');
  genBtn.disabled = true; cancelBtn.disabled = true;

  try {
    const words = extractWordsFromText(txt);
    if (!words || words.length === 0) {
      addPenLog('Build-from-text: no words found in input.');
      alert('No valid words found in the pasted text.');
      return;
    }

    addPenLog(`Build-from-text: found ${words.length} words. Starting creation...`);

    let prevId = null;
    let createdCount = 0;
    let lastCreated = null;

    // create nodes sequentially
    for (let i = 0; i < words.length; i++) {
      const word = words[i].trim();
      if (!word) continue;

      // prepare payload: name = word; connect_to prevId for sequence nodes
      const payload = { name: word, sequence: true };
      if (prevId !== null) payload.connect_to = Number(prevId);

      addPenLog(`Build-from-text: creating node for word "${word}" (connect_to: ${payload.connect_to || '(none)'})`);

      try {
        const resp = await fetch('/api/nodes', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) {
          const txtErr = await resp.text();
          addPenLog(`Build-from-text: failed to create "${word}" — server responded: ${txtErr}`);
          // stop or continue? We'll continue but abort if server fails badly
          // optionally: break;
        } else {
          const created = await resp.json();
          createdCount++;
          lastCreated = created && created.id ? created.id : lastCreated;
          addPenLog(`Build-from-text: created node #${created.id}  name="${created.name}"  (x:${created.x}, y:${created.y})`);
          // next node should connect to this one
          prevId = created.id;
        }
      } catch (err) {
        addPenLog(`Build-from-text: network error creating "${word}": ${err}`);
        // continue to next word
      }
      // optional: tiny pause so server isn't hammered (uncomment if needed)
      // await new Promise(res => setTimeout(res, 40));
    }

    addPenLog(`Build-from-text: finished. Created ${createdCount} nodes.`);

    // refresh scene
    await loadData();

    // select the last created node for convenience
    if (lastCreated) {
      selectNode(lastCreated);
      addPenLog(`Build-from-text: selected last created node #${lastCreated}.`);
    }

    // close modal
    m.style.display = 'none';
    alert(`Graph generated: created ${createdCount} nodes.`);
  } finally {
    genBtn.disabled = false;
    cancelBtn.disabled = false;
  }
});
*/

// ---------- Build graph from pasted text (preserve whitespace, include text field, classification IDs) ----------

// Tokenizer that preserves whitespace tokens (spaces/newlines/tabs) and non-space tokens.
function extractTokensPreserveWhitespace(text) {
  if (text == null) return [];
  const tokens = [];
  // capture runs of whitespace OR runs of non-whitespace
  const re = /(\s+|[^\s]+)/g;
  let m;
  while ((m = re.exec(text)) !== null) {
    tokens.push(m[1]);
  }
  return tokens;
}

// Classification scheme:
// - explicit IDs for whitespace types: space -> 20, newline -> 21, tab -> 22
// - punctuation -> 30
// - word tokens -> cyclic IDs from wordClassIds[]
const wordClassIds = [100, 101, 102, 103]; // cyclic set for words
let wordClassIndex = 0;

function classifyToken(token, index) {
  // whitespace exact checks
  if (/^\s+$/.test(token)) {
    if (token === ' ') return 20;
    if (token === '\n' || token === '\r\n') return 21;
    if (token === '\t') return 22;
    // other whitespace sequences: if contains newline prefer newline id, else space id
    if (/\r|\n/.test(token)) return 21;
    return 20;
  }
  // punctuation only (no letters/digits)
  if (/^[^\p{L}\p{N}]+$/u.test(token)) {
    return 30;
  }
  // otherwise treat as a word -> pick cyclic id
  const id = wordClassIds[wordClassIndex % wordClassIds.length];
  wordClassIndex++;
  return id;
}

// Open modal button wiring (keeps same UI behavior)
document.getElementById('textGraphBtn').addEventListener('click', () => {
  const m = document.getElementById('modal-textgraph');
  if (m) m.style.display = 'flex';
  const ta = document.getElementById('textGraphArea');
  if (ta) ta.value = '';
  setTimeout(() => ta && ta.focus(), 50);
});
document.getElementById('textGraphCancel').addEventListener('click', () => {
  const m = document.getElementById('modal-textgraph');
  if (m) m.style.display = 'none';
});

// Main generation handler (preserves whitespace tokens, sends `name`, `text`, and `description`=classification ID)
document.getElementById('textGraphGenerate').addEventListener('click', async () => {
  const m = document.getElementById('modal-textgraph');
  const ta = document.getElementById('textGraphArea');
  if (!ta || !m) return;
  const txt = ta.value;
  if (!txt) { alert('Paste some text first'); return; }

  const genBtn = document.getElementById('textGraphGenerate');
  const cancelBtn = document.getElementById('textGraphCancel');
  genBtn.disabled = true; cancelBtn.disabled = true;

  try {
    const tokens = extractTokensPreserveWhitespace(txt);
    if (!tokens || tokens.length === 0) {
      addPenLog('Build-from-text: no tokens found in input.');
      alert('No tokens found in the pasted text.');
      return;
    }

    addPenLog(`Build-from-text: found ${tokens.length} tokens (including whitespace). Starting creation...`);
    addPenLog('Classification rules: space=20, newline=21, tab=22, punctuation=30, words cyclic-> ' + JSON.stringify(wordClassIds));

    let prevId = null;
    let createdCount = 0;
    let lastCreated = null;
    wordClassIndex = 0; // reset cyclic index per generation

    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i]; // DO NOT trim — we preserve whitespace
      if (token === null || token === undefined) continue;

      const classId = classifyToken(token, i);

      // prepare payload:
      // - name: the token itself (may include whitespace)
      // - text: the token itself (keeps whitespace)
      // - description: classification ID (so it gets stored in DB)
      // - sequence: true
      // - connect_to: prevId (for sequential chain)
      const payload = {
        name: token,
        text: token,
        description: String(classId),
        sequence: true
      };
      if (prevId !== null) payload.connect_to = Number(prevId);

      // For logging provide a readable representation for whitespace tokens
      const repr = token.replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t');
      addPenLog(`Build-from-text: creating token #${i+1}/${tokens.length} repr="${repr}" class=${classId} connect_to=${payload.connect_to || '(none)'}`);

      try {
        const resp = await fetch('/api/nodes', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) {
          const txtErr = await resp.text();
          addPenLog(`Build-from-text: FAILED to create token "${repr}" — server: ${txtErr}`);
        } else {
          const created = await resp.json();
          createdCount++;
          lastCreated = created && created.id ? created.id : lastCreated;
          addPenLog(`Build-from-text: created node #${created.id} name(repr)="${repr}" stored_class=${classId} x:${created.x}, y:${created.y}`);
          prevId = created.id;
        }
      } catch (err) {
        addPenLog(`Build-from-text: network error creating token "${repr}": ${err}`);
      }

      // optional small delay if needed:
      // await new Promise(res => setTimeout(res, 20));
    }

    addPenLog(`Build-from-text: finished. Created ${createdCount} nodes of ${tokens.length} tokens.`);

    // refresh data & select last created
    await loadData();
    if (lastCreated) {
      selectNode(lastCreated);
      addPenLog(`Build-from-text: selected last created node #${lastCreated}.`);
    }

    m.style.display = 'none';
    alert(`Graph generated: created ${createdCount} nodes (out of ${tokens.length} tokens).`);
  } finally {
    genBtn.disabled = false;
    cancelBtn.disabled = false;
  }
});


</script>
</body>
</html>
